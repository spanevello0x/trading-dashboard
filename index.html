<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QuickBot Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e4e4e4;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2rem;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
    }
    .card {
      background: rgba(255,255,255,0.05);
      border-radius: 16px;
      padding: 20px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    .card.full { grid-column: 1 / -1; }
    .card h2 {
      font-size: 1rem;
      color: #888;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .stat { font-size: 2rem; font-weight: bold; color: #00ff88; }
    .stat.negative { color: #ff4757; }
    .stat-label { font-size: 0.9rem; color: #666; }
    
    .feed {
      max-height: 400px;
      overflow-y: auto;
      font-family: 'Monaco', 'Consolas', monospace;
      font-size: 0.8rem;
      background: rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 10px;
    }
    .feed-item {
      padding: 6px 8px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      line-height: 1.4;
    }
    .feed-item:last-child { border-bottom: none; }
    .feed-time { color: #666; }
    
    .position {
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 8px;
    }
    .position:last-child { margin-bottom: 0; }
    .position-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .position-coin { font-size: 1.1rem; font-weight: bold; }
    .position-side {
      padding: 3px 10px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: bold;
    }
    .position-side.long { background: rgba(0,255,136,0.2); color: #00ff88; }
    .position-side.short { background: rgba(255,71,87,0.2); color: #ff4757; }
    .position-details {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      font-size: 0.8rem;
    }
    .position-detail label { color: #666; display: block; font-size: 0.7rem; }
    .pnl-positive { color: #00ff88; }
    .pnl-negative { color: #ff4757; }
    
    .prices {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      text-align: center;
    }
    .price-item {
      background: rgba(255,255,255,0.03);
      padding: 12px;
      border-radius: 8px;
    }
    .price-coin { font-weight: bold; color: #888; font-size: 0.9rem; }
    .price-value { font-size: 1.2rem; margin-top: 4px; }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 15px;
      text-align: center;
    }
    
    .trades-list { max-height: 200px; overflow-y: auto; }
    .trade-item {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 8px;
      padding: 6px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      font-size: 0.75rem;
    }
    .trade-item:first-child { color: #666; font-weight: bold; }
    .trade-buy { color: #00ff88; }
    .trade-sell { color: #ff4757; }
    
    .chart-container {
      height: 200px;
      position: relative;
    }
    
    .pnl-summary {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 15px;
      text-align: center;
    }
    .pnl-stat {
      background: rgba(255,255,255,0.03);
      padding: 10px;
      border-radius: 8px;
    }
    .pnl-stat-value {
      font-size: 1.3rem;
      font-weight: bold;
    }
    .pnl-stat-label {
      font-size: 0.7rem;
      color: #666;
      margin-top: 2px;
    }
    
    .refresh-info { text-align: center; color: #666; font-size: 0.8rem; margin-top: 20px; }
    .explorer-link { text-align: center; margin-top: 10px; }
    .explorer-link a { color: #00d9ff; text-decoration: none; font-size: 0.85rem; }
    
    ::-webkit-scrollbar { width: 5px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.02); }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    
    @media (max-width: 768px) {
      .grid { grid-template-columns: 1fr; }
      .position-details { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ö° QuickBot Dashboard</h1>
    
    <div class="grid">
      <div class="card">
        <h2>üí∞ Conta</h2>
        <div class="stats-grid">
          <div>
            <div class="stat" id="balance">-</div>
            <div class="stat-label">Balance</div>
          </div>
          <div>
            <div class="stat" id="pnl">-</div>
            <div class="stat-label">PnL Total</div>
          </div>
          <div>
            <div class="stat" id="positions-count">-</div>
            <div class="stat-label">Posi√ß√µes</div>
          </div>
        </div>
        <div class="explorer-link">
          <a href="https://hypurrscan.io/address/0x4FFf1187E66b66bC8E31886F2b861f951736a276" target="_blank">üìä Ver no Explorer ‚Üí</a>
        </div>
      </div>
      
      <div class="card">
        <h2>üìä Pre√ßos</h2>
        <div class="prices">
          <div class="price-item">
            <div class="price-coin">BTC</div>
            <div class="price-value" id="price-btc">-</div>
          </div>
          <div class="price-item">
            <div class="price-coin">ETH</div>
            <div class="price-value" id="price-eth">-</div>
          </div>
          <div class="price-item">
            <div class="price-coin">SOL</div>
            <div class="price-value" id="price-sol">-</div>
          </div>
        </div>
      </div>
      
      <div class="card">
        <h2>üìà Posi√ß√µes Abertas</h2>
        <div id="positions">Carregando...</div>
      </div>
      
      <!-- NOVO: Gr√°fico de Performance -->
      <div class="card">
        <h2>üìä Performance (PnL % Acumulado)</h2>
        <div class="pnl-summary">
          <div class="pnl-stat">
            <div class="pnl-stat-value pnl-positive" id="total-pnl-pct">0%</div>
            <div class="pnl-stat-label">PnL Total</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-value" id="win-rate">0%</div>
            <div class="pnl-stat-label">Win Rate</div>
          </div>
          <div class="pnl-stat">
            <div class="pnl-stat-value" id="total-trades">0</div>
            <div class="pnl-stat-label">Trades Fechados</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="pnl-chart"></canvas>
        </div>
      </div>
      
      <div class="card">
        <h2>üìú Trades Recentes</h2>
        <div class="trades-list" id="trades">Carregando...</div>
      </div>
      
      <div class="card full">
        <h2>üß† Feed de Pensamentos</h2>
        <div class="feed" id="feed">Conectando...</div>
      </div>
    </div>
    
    <div class="refresh-info">
      Atualiza√ß√£o a cada 5s | <span id="last-update">-</span>
    </div>
  </div>

  <script>
    const WALLET = '0x4FFf1187E66b66bC8E31886F2b861f951736a276';
    const HL_API = 'https://api.hyperliquid.xyz/info';
    const INITIAL_CAPITAL = 15.52; // Capital inicial em USDC
    
    let feedItems = [];
    let prevData = {};
    let pnlChart = null;
    
    function formatMoney(n) { return '$' + n.toFixed(2); }
    function formatPrice(n) { return n >= 10000 ? '$' + n.toFixed(0) : '$' + n.toFixed(2); }
    function formatTime() { return new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
    
    async function hlPost(body) {
      const res = await fetch(HL_API, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });
      return res.json();
    }
    
    function addThought(msg) {
      const time = formatTime();
      feedItems.unshift({ time, msg });
      if (feedItems.length > 30) feedItems = feedItems.slice(0, 30);
    }
    
    // Inicializa o gr√°fico de PnL
    function initPnLChart() {
      const ctx = document.getElementById('pnl-chart').getContext('2d');
      pnlChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'PnL % Acumulado',
            data: [],
            borderColor: '#00ff88',
            backgroundColor: 'rgba(0, 255, 136, 0.1)',
            fill: true,
            tension: 0.3,
            pointRadius: 3,
            pointBackgroundColor: '#00ff88',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: (ctx) => `PnL: ${ctx.parsed.y >= 0 ? '+' : ''}${ctx.parsed.y.toFixed(2)}%`
              }
            }
          },
          scales: {
            x: {
              display: true,
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { 
                color: '#666',
                maxTicksLimit: 6,
                font: { size: 10 }
              }
            },
            y: {
              display: true,
              grid: { color: 'rgba(255,255,255,0.05)' },
              ticks: { 
                color: '#666',
                callback: v => v.toFixed(1) + '%',
                font: { size: 10 }
              }
            }
          }
        }
      });
    }
    
    // Processa trades fechados e calcula PnL acumulado
    function processClosedTrades(fills) {
      // Agrupa trades por ordem (oid) para encontrar pares open/close
      const trades = [];
      const openPositions = {};
      
      // Ordena por tempo (mais antigo primeiro)
      const sortedFills = [...fills].sort((a, b) => a.time - b.time);
      
      for (const fill of sortedFills) {
        const coin = fill.coin;
        const side = fill.side; // 'B' ou 'A' (buy/sell)
        const size = parseFloat(fill.sz);
        const price = parseFloat(fill.px);
        const time = fill.time;
        const closedPnl = parseFloat(fill.closedPnl || 0);
        
        // Se tem closedPnl, √© um trade fechado
        if (closedPnl !== 0) {
          // Calcula % baseado no valor da posi√ß√£o
          // Estimativa: usa o pre√ßo de entrada aproximado
          const positionValue = size * price;
          const pnlPct = (closedPnl / positionValue) * 100;
          
          trades.push({
            time,
            coin,
            pnl: closedPnl,
            pnlPct,
            side: side === 'B' ? 'BUY' : 'SELL'
          });
        }
      }
      
      return trades;
    }
    
    // Atualiza o gr√°fico de PnL
    function updatePnLChart(fills) {
      const closedTrades = processClosedTrades(fills);
      
      if (closedTrades.length === 0) {
        document.getElementById('total-pnl-pct').textContent = '0%';
        document.getElementById('win-rate').textContent = '0%';
        document.getElementById('total-trades').textContent = '0';
        return;
      }
      
      // Calcula PnL acumulado
      let cumPnl = 0;
      const dataPoints = [];
      let wins = 0;
      let losses = 0;
      
      for (const trade of closedTrades) {
        cumPnl += trade.pnl;
        const cumPnlPct = (cumPnl / INITIAL_CAPITAL) * 100;
        
        dataPoints.push({
          time: trade.time,
          pnlPct: cumPnlPct,
          label: new Date(trade.time).toLocaleString('pt-BR', { 
            day: '2-digit', 
            month: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
          })
        });
        
        if (trade.pnl > 0) wins++;
        else if (trade.pnl < 0) losses++;
      }
      
      // Atualiza estat√≠sticas
      const totalPnlPct = (cumPnl / INITIAL_CAPITAL) * 100;
      const winRate = closedTrades.length > 0 ? (wins / closedTrades.length) * 100 : 0;
      
      const totalPnlEl = document.getElementById('total-pnl-pct');
      totalPnlEl.textContent = (totalPnlPct >= 0 ? '+' : '') + totalPnlPct.toFixed(2) + '%';
      totalPnlEl.className = 'pnl-stat-value ' + (totalPnlPct >= 0 ? 'pnl-positive' : 'pnl-negative');
      
      document.getElementById('win-rate').textContent = winRate.toFixed(0) + '%';
      document.getElementById('total-trades').textContent = closedTrades.length;
      
      // Atualiza gr√°fico
      pnlChart.data.labels = dataPoints.map(d => d.label);
      pnlChart.data.datasets[0].data = dataPoints.map(d => d.pnlPct);
      
      // Muda cor se negativo
      if (totalPnlPct < 0) {
        pnlChart.data.datasets[0].borderColor = '#ff4757';
        pnlChart.data.datasets[0].backgroundColor = 'rgba(255, 71, 87, 0.1)';
        pnlChart.data.datasets[0].pointBackgroundColor = '#ff4757';
      } else {
        pnlChart.data.datasets[0].borderColor = '#00ff88';
        pnlChart.data.datasets[0].backgroundColor = 'rgba(0, 255, 136, 0.1)';
        pnlChart.data.datasets[0].pointBackgroundColor = '#00ff88';
      }
      
      pnlChart.update('none');
    }
    
    function generateThoughts(positions, mids) {
      for (const p of positions) {
        const coin = p.position.coin;
        const size = parseFloat(p.position.szi);
        const pnl = parseFloat(p.position.unrealizedPnl);
        const entry = parseFloat(p.position.entryPx);
        const isLong = size > 0;
        const price = parseFloat(mids[coin] || 0);
        const pnlPct = (pnl / (Math.abs(size) * entry)) * 100;
        
        const key = `pos_${coin}`;
        const lastPnl = prevData[key];
        
        // S√≥ adiciona se mudou significativamente
        if (lastPnl === undefined || Math.abs(pnlPct - lastPnl) >= 0.3) {
          prevData[key] = pnlPct;
          
          let thought;
          if (pnlPct >= 1.5) {
            thought = `üöÄ ${coin} voando! +${pnlPct.toFixed(2)}% de lucro, quase no TP!`;
          } else if (pnlPct >= 0.5) {
            thought = `üìà ${coin} no verde +${pnlPct.toFixed(2)}%, trade andando bem`;
          } else if (pnlPct >= -0.3) {
            thought = `‚è≥ ${coin} ${pnlPct >= 0 ? '+' : ''}${pnlPct.toFixed(2)}%, lateralizando...`;
          } else if (pnlPct >= -0.7) {
            thought = `üò¨ ${coin} ${pnlPct.toFixed(2)}%, perdendo mas SL ainda longe`;
          } else {
            thought = `‚ö†Ô∏è ${coin} ${pnlPct.toFixed(2)}%, chegando perto do SL... segurando`;
          }
          
          addThought(thought);
        }
      }
      
      // An√°lise de pre√ßos para coins sem posi√ß√£o
      const posCoins = positions.map(p => p.position.coin);
      for (const coin of ['BTC', 'ETH', 'SOL']) {
        if (posCoins.includes(coin)) continue;
        
        const price = parseFloat(mids[coin] || 0);
        const lastPrice = prevData[`price_${coin}`];
        
        if (lastPrice) {
          const change = ((price - lastPrice) / lastPrice) * 100;
          if (Math.abs(change) > 0.15) {
            prevData[`price_${coin}`] = price;
            const dir = change > 0 ? 'üìà' : 'üìâ';
            addThought(`üîç ${coin} $${formatPrice(price)} ${dir} ${change > 0 ? '+' : ''}${change.toFixed(2)}% - analisando...`);
          }
        } else {
          prevData[`price_${coin}`] = price;
        }
      }
    }
    
    async function fetchData() {
      try {
        const [account, mids, fills] = await Promise.all([
          hlPost({ type: 'clearinghouseState', user: WALLET }),
          hlPost({ type: 'allMids' }),
          hlPost({ type: 'userFills', user: WALLET })
        ]);
        
        const balance = parseFloat(account.marginSummary?.accountValue || 0);
        const positions = account.assetPositions || [];
        const totalPnl = positions.reduce((s, p) => s + parseFloat(p.position.unrealizedPnl || 0), 0);
        
        document.getElementById('balance').textContent = formatMoney(balance);
        document.getElementById('positions-count').textContent = positions.length + '/5';
        
        const pnlEl = document.getElementById('pnl');
        pnlEl.textContent = (totalPnl >= 0 ? '+' : '') + formatMoney(totalPnl);
        pnlEl.className = 'stat ' + (totalPnl >= 0 ? '' : 'negative');
        
        document.getElementById('price-btc').textContent = formatPrice(parseFloat(mids.BTC || 0));
        document.getElementById('price-eth').textContent = formatPrice(parseFloat(mids.ETH || 0));
        document.getElementById('price-sol').textContent = formatPrice(parseFloat(mids.SOL || 0));
        
        // Atualiza gr√°fico de PnL
        updatePnLChart(fills || []);
        
        // Generate thoughts
        generateThoughts(positions, mids);
        
        // Positions
        const posEl = document.getElementById('positions');
        if (positions.length > 0) {
          posEl.innerHTML = positions.map(p => {
            const size = parseFloat(p.position.szi);
            const isLong = size > 0;
            const pnl = parseFloat(p.position.unrealizedPnl);
            const entry = parseFloat(p.position.entryPx);
            const current = parseFloat(mids[p.position.coin] || entry);
            const lev = parseFloat(p.position.leverage?.value || 1);
            
            return `<div class="position">
              <div class="position-header">
                <span class="position-coin">${p.position.coin}</span>
                <span class="position-side ${isLong ? 'long' : 'short'}">${isLong ? 'LONG' : 'SHORT'}</span>
              </div>
              <div class="position-details">
                <div class="position-detail"><label>Entry</label><span>${formatPrice(entry)}</span></div>
                <div class="position-detail"><label>Atual</label><span>${formatPrice(current)}</span></div>
                <div class="position-detail"><label>PnL</label><span class="${pnl >= 0 ? 'pnl-positive' : 'pnl-negative'}">${pnl >= 0 ? '+' : ''}${formatMoney(pnl)}</span></div>
                <div class="position-detail"><label>Lev</label><span>${lev}x</span></div>
              </div>
            </div>`;
          }).join('');
        } else {
          posEl.innerHTML = '<div style="color:#666;text-align:center;padding:20px">Sem posi√ß√µes</div>';
        }
        
        // Trades
        const tradesEl = document.getElementById('trades');
        const recent = (fills || []).slice(0, 10);
        if (recent.length > 0) {
          tradesEl.innerHTML = `<div class="trade-item"><span>Data</span><span>Coin</span><span>Side</span><span>Price</span></div>` +
            recent.map(f => {
              const date = new Date(f.time).toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
              const isBuy = f.side === 'B';
              return `<div class="trade-item"><span>${date}</span><span>${f.coin}</span><span class="${isBuy ? 'trade-buy' : 'trade-sell'}">${isBuy ? 'BUY' : 'SELL'}</span><span>${formatPrice(parseFloat(f.px))}</span></div>`;
            }).join('');
        } else {
          tradesEl.innerHTML = '<div style="color:#666;text-align:center;padding:20px">Sem trades</div>';
        }
        
        // Feed
        const feedEl = document.getElementById('feed');
        feedEl.innerHTML = feedItems.length > 0 
          ? feedItems.map(f => `<div class="feed-item"><span class="feed-time">[${f.time}]</span> ${f.msg}</div>`).join('')
          : '<div style="color:#666;text-align:center;padding:20px">Aguardando...</div>';
        
        document.getElementById('last-update').textContent = formatTime();
        
      } catch (e) { console.error(e); }
    }
    
    // Initial thought
    addThought('‚ÑπÔ∏è QuickBot Dashboard conectado!');
    
    // Inicializa gr√°fico
    initPnLChart();
    
    fetchData();
    setInterval(fetchData, 5000);
  </script>
</body>
</html>
